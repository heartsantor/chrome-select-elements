import microMemoize from 'micro-memoize';
import { isBackgroundPage } from 'webext-detect-page';
import toMilliseconds from '@sindresorhus/to-milliseconds';
import chromeP from 'webext-polyfill-kinda';
function timeInTheFuture(time) {
    return Date.now() + toMilliseconds(time);
}
async function has(key) {
    return (await _get(key, false)) !== undefined;
}
async function _get(key, remove) {
    const internalKey = `cache:${key}`;
    const storageData = await chromeP.storage.local.get(internalKey);
    const cachedItem = storageData[internalKey];
    if (cachedItem === undefined) {
        // `undefined` means not in cache
        return;
    }
    if (Date.now() > cachedItem.maxAge) {
        if (remove) {
            await chromeP.storage.local.remove(internalKey);
        }
        return;
    }
    return cachedItem;
}
async function get(key) {
    var _a;
    return (_a = (await _get(key, true))) === null || _a === void 0 ? void 0 : _a.data;
}
async function set(key, value, maxAge = { days: 30 }) {
    if (arguments.length < 2) {
        throw new TypeError('Expected a value as the second argument');
    }
    if (typeof value === 'undefined') {
        await delete_(key);
    }
    else {
        const internalKey = `cache:${key}`;
        await chromeP.storage.local.set({
            [internalKey]: {
                data: value,
                maxAge: timeInTheFuture(maxAge),
            },
        });
    }
    return value;
}
async function delete_(key) {
    const internalKey = `cache:${key}`;
    return chromeP.storage.local.remove(internalKey);
}
async function deleteWithLogic(logic) {
    var _a;
    const wholeCache = (await chromeP.storage.local.get());
    const removableItems = [];
    for (const [key, value] of Object.entries(wholeCache)) {
        if (key.startsWith('cache:') && ((_a = logic === null || logic === void 0 ? void 0 : logic(value)) !== null && _a !== void 0 ? _a : true)) {
            removableItems.push(key);
        }
    }
    if (removableItems.length > 0) {
        await chromeP.storage.local.remove(removableItems);
    }
}
async function deleteExpired() {
    await deleteWithLogic(cachedItem => Date.now() > cachedItem.maxAge);
}
async function clear() {
    await deleteWithLogic();
}
function function_(getter, { cacheKey, maxAge = { days: 30 }, staleWhileRevalidate = { days: 0 }, shouldRevalidate, } = {}) {
    const getSet = async (key, args) => {
        const freshValue = await getter(...args);
        if (freshValue === undefined) {
            await delete_(key);
            return;
        }
        const milliseconds = toMilliseconds(maxAge) + toMilliseconds(staleWhileRevalidate);
        return set(key, freshValue, { milliseconds });
    };
    return microMemoize((async (...args) => {
        const userKey = cacheKey ? cacheKey(args) : args[0];
        const cachedItem = await _get(userKey, false);
        if (cachedItem === undefined || (shouldRevalidate === null || shouldRevalidate === void 0 ? void 0 : shouldRevalidate(cachedItem.data))) {
            return getSet(userKey, args);
        }
        // When the expiration is earlier than the number of days specified by `staleWhileRevalidate`, it means `maxAge` has already passed and therefore the cache is stale.
        if (timeInTheFuture(staleWhileRevalidate) > cachedItem.maxAge) {
            setTimeout(getSet, 0, userKey, args);
        }
        return cachedItem.data;
    }));
}
const cache = {
    has,
    get,
    set,
    clear,
    function: function_,
    delete: delete_,
};
function init() {
    // Make it available globally for ease of use
    window.webextStorageCache = cache;
    // Automatically clear cache every day
    if (!isBackgroundPage()) {
        return;
    }
    if (chrome.alarms) {
        chrome.alarms.create('webext-storage-cache', {
            delayInMinutes: 1,
            periodInMinutes: 60 * 24,
        });
        let lastRun = 0; // Homemade debouncing due to `chrome.alarms` potentially queueing this function
        chrome.alarms.onAlarm.addListener(alarm => {
            if (alarm.name === 'webext-storage-cache' && lastRun < Date.now() - 1000) {
                lastRun = Date.now();
                void deleteExpired();
            }
        });
    }
    else {
        setTimeout(deleteExpired, 60000); // Purge cache on launch, but wait a bit
        setInterval(deleteExpired, 1000 * 3600 * 24);
    }
}
init();
export default cache;
